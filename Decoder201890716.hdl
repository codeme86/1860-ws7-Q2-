CHIP Decoder201890716 {
    IN A, B, C, D;
    OUT a, b, c, d, e, f, g;

    PARTS:
    // Inverted inputs
    Not(in=A, out=nota);
    Not(in=B, out=notb);
    Not(in=C, out=notc);
    Not(in=D, out=notd);

    // --- Segment a ---
    Or(a=B, b=D, out=w_a1);
    And(a=notb, b=notd, out=w_a2);
    And(a=nota, b=notc, out=w_a3);
    And(a=A, b=C, out=w_a4);
    Or(a=w_a1, b=w_a2, out=w_a5);
    Or(a=w_a3, b=w_a4, out=w_a6);
    Or(a=w_a5, b=w_a6, out=a);

    // --- Segment b ---
    Or(a=A, b=C, out=w_b1);
    And(a=notc, b=notd, out=w_b2);
    And(a=B, b=notd, out=w_b3);
    Or(a=w_b1, b=w_b2, out=w_b4);
    Or(a=w_b4, b=w_b3, out=b);

    // --- Segment c ---
    Or(a=A, b=notd, out=w_c1);
    And(a=B, b=notc, out=w_c2);
    Or(a=w_c1, b=w_c2, out=c);

    // --- Segment d (Confirmed working logic from your 13/16 HDL) ---
    // Matching 0000
    And(a=nota, b=notb, out=w_d1);
    And(a=notc, b=notd, out=w_d2);
    And(a=w_d1, b=w_d2, out=m0);
    // Matching 0010
    And(a=nota, b=notb, out=w_d3);
    And(a=C, b=notd, out=w_d4);
    And(a=w_d3, b=w_d4, out=m1);
    // Matching 0110
    And(a=nota, b=B, out=w_d5);
    And(a=C, b=notd, out=w_d6);
    And(a=w_d5, b=w_d6, out=m2);
    // Matching 1000
    And(a=A, b=notb, out=w_d7);
    And(a=notc, b=notd, out=w_d8);
    And(a=w_d7, b=w_d8, out=m3);
    // Matching 1010
    And(a=A, b=notb, out=w_d9);
    And(a=C, b=notd, out=w_d10);
    And(a=w_d9, b=w_d10, out=m4);
    // Matching 1011
    And(a=A, b=notb, out=w_d11);
    And(a=C, b=D, out=w_d12);
    And(a=w_d11, b=w_d12, out=m5);
    // Matching 1100
    And(a=A, b=B, out=w_d13);
    And(a=notc, b=notd, out=w_d14);
    And(a=w_d13, b=w_d14, out=m6);
    // Matching 1110
    And(a=A, b=B, out=w_d15);
    And(a=C, b=notd, out=w_d16);
    And(a=w_d15, b=w_d16, out=m7);
    // Combine
    Or(a=m0, b=m1, out=o1);
    Or(a=o1, b=m2, out=o2);
    Or(a=o2, b=m3, out=o3);
    Or(a=o3, b=m4, out=o4);
    Or(a=o4, b=m5, out=o5);
    Or(a=o5, b=m6, out=o6);
    Or(a=o6, b=m7, out=d);

    // --- Segment e ---
    And(a=notc, b=notd, out=w_e1);
    Or(a=nota, b=w_e1, out=e);

    // --- Segment f ---
    And(a=nota, b=notc, out=w_f1);
    Or(a=B, b=w_f1, out=f);

    // --- Segment g ---
    Or(a=B, b=D, out=w_g1);
    And(a=notb, b=notd, out=w_g2);
    Or(a=w_g1, b=w_g2, out=g);
}